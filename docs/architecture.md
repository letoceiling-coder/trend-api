## Архитектура проекта (Laravel + Vue + TrendAgent)

Этот документ фиксирует целевую архитектуру интеграции с TrendAgent, основанную на проведённом ревёрс‑инжиниринге.

---

## 1. Слои системы

### 1.1. External API Layer

- Отвечает за взаимодействие с внешними API TrendAgent:
  - `api.trendagent.ru`
  - `apartment-api.trendagent.ru`
  - `parkings-api.trendagent.ru`
  - `commerce-api.trendagent.ru`
  - `rewards-api.trendagent.ru`
  - `files.trendagent.ru`
  - `video.trendagent.ru`
  - `contacts-api.trendagent.ru`
  - `mortgage-api.trendagent.ru`
  - `3d-tour-api.trendagent.ru`
  - `webinars-api.trendagent.ru` и др.
- В нашем проекте этот слой реализуется:
  - на бекенде Laravel — как HTTP‑клиенты/репозитории;
  - на фронтенде Vue — как axios‑клиент к нашему Laravel‑API.

### 1.2. Domain Layer

- Инкапсулирует доменные сущности и логику:
  - `Block`, `Apartment`, `CommercePremise`, `ParkingBlock`, `ParkingPlace`, `Village`, `Plot`, `RewardSettings` и др.
- Здесь же:
  - маппинг JSON‑ответов TrendAgent → доменных моделей;
  - подготовка данных под нужды UI/отчётов;
  - валидация и бизнесс‑правила, специфичные для нашего проекта.

### 1.3. Cache Layer

- Отвечает за кеширование:
  - справочников (`directories`, `filters`) по доменам и городу;
  - редко меняющихся структурных данных (`Block`, `Village`, `RewardSettings`, `File`, `Video` и т.д.);
  - результатов сложных поисковых запросов (по возможности).
- Может быть реализован:
  - на Laravel через Redis или файловый кеш;
  - с чётким TTL и инвалидацией по городу/домену.

### 1.4. Storage Layer

- Собственная БД (PostgreSQL/MySQL и т.п.) и файлы проекта.
- Содержит:
  - наши сущности (пользователи, их настройки, привязки к TrendAgent, логи действий, кешированные данные и т.п.);
  - возможно — денормализованные копии данных TrendAgent для оффлайн‑аналитики/быстрых выборок.

### 1.5. Frontend Layer

- Vue‑SPA, работающая только с нашим Laravel‑API.
- Отвечает за:
  - отображение списков/таблиц/карт/планировок/чекербордов;
  - реализацию SSO‑авторизации и refresh‑логики на уровне HTTP‑клиента;
  - хранение `auth_token` **исключительно в памяти**;
  - управление фильтрами, сортировками и состоянием UI.

---

## 2. Взаимодействие Laravel с TrendAgent

### 2.1. Основной поток запроса

1. Vue отправляет запрос к нашему бекенду (например, `/api/trendagent/objects/list`).
2. В запросе присутствует:
   - `Authorization: Bearer <auth_token>` (который живёт в памяти фронта),
   - cookies браузера (для SSO) — если это SSO‑вызовы, и запрос помечен `withCredentials`.
3. Laravel‑контроллер вызывает соответствующий сервис доменного слоя:
   - `TrendAgentObjectsService`, `TrendAgentCommerceService` и т.д.
4. Сервис использует HTTP‑клиент (Guzzle/HTTP‑фасад) для обращения к внешнему API TrendAgent:
   - заголовки `Authorization`, cookies и query‑параметры (`city`, `lang`) **проксируются как есть**;
   - никакого самостоятельного управления жизненным циклом токена на бекенде нет.
5. Ответ TrendAgent:
   - парсится, при необходимости нормализуется в доменные модели;
   - возвращается во фронт как JSON.

### 2.2. Особенности SSO / токенов

- Backend:
  - **не знает** про refresh‑токен;
  - не вызывает `POST /v1/login` или `GET /v1/auth_token` самостоятельно;
  - получает уже готовый `auth_token` от фронтенда и использует его как «чёрный ящик».
- Frontend:
  - управляет `auth_token` и `refresh`‑флоу;
  - при 401/403 делает refresh через `sso-api.trend.tech/v1/auth_token`, затем повторяет запрос к Laravel;
  - Laravel просто видит новый `Authorization: Bearer ...` и продолжает работать.

### 2.3. Почему нельзя проксировать TrendAgent напрямую с фронта

Несмотря на то, что технически фронтенд может ходить в TrendAgent напрямую, в архитектуре проекта предусмотрен **обязательный бекенд‑слой** по ряду причин:

- **Инкапсуляция контрактов**:
  - внешний API может меняться без нашего ведома;
  - бекенд‑слой позволяет централизованно адаптировать изменения и не ломать UI.
- **Кеширование**:
  - многие справочники и структурные данные удобно кешировать именно на бекенде;
  - это уменьшает нагрузку и ускоряет работу UI.
- **Безопасность**:
  - бекенд может скрывать часть технических деталей:
    - нестабильные/экспериментальные поля;
    - внутренние идентификаторы;
  - можно внедрять дополнительную авторизацию/аудит поверх TrendAgent.
- **Дополнительная логика**:
  - агрегация и обогащение данных;
  - кросс‑доменные отчёты;
  - интеграция с другими источниками (CRM, внутренние сервисы).

---

## 3. Почему backend НЕ должен управлять токенами

### 3.1. Ограничения SSO

- `refresh_token` хранится в HttpOnly cookie, доступной только браузеру и домену SSO.
- Для продления токена (`GET /v1/auth_token/`) требуется:
  - присутствие этого cookie в запросе,
  - контекст браузера (CORS/withCredentials).
- Backend, работающий как отдельный сервис, **не имеет доступа** к этим куки по умолчанию.

### 3.2. Риски неправильной реализации

- Попытка обновлять токен на бекенде:
  - приведёт к необходимости «сохранять» refresh‑токен, что противоречит требованиям безопасности;
  - создаст расхождение между состоянием сессии в браузере и на сервере.
- Повторный логин по расписанию:
  - ломает реальные пользовательские сессии;
  - мешает корректной работе SSO (двойные сессии, некорректные логи).

### 3.3. Правильное разделение ответственности

- **Фронт (Vue)**:
  - полностью отвечает за `auth_token` и refresh;
  - использует axios‑interceptor и мьютекс для управления жизненным циклом токена;
  - передаёт `auth_token` в заголовках к Laravel.
- **Бекенд (Laravel)**:
  - не вмешивается в refresh‑процессы;
  - проверяет только собственную авторизацию пользователя (если нужна);
  - при проксировании к TrendAgent всегда использует тот токен, который предоставлен фронтом.

---

## 4. Расширяемость по доменам

При добавлении новых доменов TrendAgent (например, ещё один поддомен или новая сущность) алгоритм такой:

1. **External API Layer**:
   - добавляется новый HTTP‑клиент/репозиторий, инкапсулирующий эндпоинты домена.
2. **Domain Layer**:
   - описывается новая доменная модель (или расширяются существующие);
   - добавляются сервисы для работы с моделью.
3. **Cache Layer**:
   - при необходимости вводятся новые кеш‑ключи по домену/городу.
4. **Frontend Layer**:
   - добавляются новые страницы Vue и маппинг UI‑фильтров на query‑параметры;
   - используется уже существующий axios‑клиент с refresh‑логикой.

При этом общие принципы остаются неизменными:

- **город** (`city_id`) и **язык** (`lang`) обязательны;
- все бизнес‑данные приходят из внешнего API (мы не дублируем функционал TrendAgent, а только адаптируем и кешируем).

